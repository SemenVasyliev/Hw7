# HW7

Домашнее задания HW7.
Содержит 3 задания.

**Темы:** Потоки, Таймеры, Безопасные коллекции, Тестирование и "Моки".

Все задания уже имеют программный каркас.

Задача программиста : 
- реализовать недостающие блоки функциональности :
> искать по тексту // TODO: или "Should be implemented by executor";
- убедится, что проходят все unit-тесты.

## Структура исходного кода
Каталог с решением имеет следующую структуру :
- **editorconfig** - файл с правилами форматирования кода; запрещен к модификации;
- **Directory.Build.props** - файл с настройки решения; запрещен к модификации;
- **Hw7.Exercise1** - проект библиотеки “Threads”;
    - **Threads.cs** - основной класс библиотеки, который должен быть доработан студентом в соответствии с заданием;
- **Hw7.Exercise2** - проект библиотеки “RecurrentJob”;
    - **RecurrentJob.cs** - класс для реализации периодичной работы, который должен быть доработан студентом в соответствии с заданием;
- **Hw7.Exercise3** - проект библиотеки “Обмен валют”;
    - **CurrencyService.cs** - класс сервиса для обмена валют; не требует доработок, кроме исправления ошибки публикации сообщений;
    - **Abstractions** - директория с интерфейсами, которые представляют абстракции сервисов для обмена валют;
        - **ICurrencyNotifications.cs** - интерфейс, который представляет абстракцию шины данных; не требует доработок;
        - **ICurrencyService.cs** - интерфейс, который представляет абстракцию сервиса для обмена валют; не требует доработок;        
        - **ICurrencyStorage.cs** - интерфейс, который представляет абстракцию базы данных; не требует доработок;                
- **Hw2.Tests** - тестовый проект для всех заданий;
    - **Exercise1** - директория с тестами для задания Hw7.Exercise1; все тесты запрещены к редактированию, кроме методов класса AppendPrimesCache, GetPrimesCache класса PrimesLoad;
    - **Exercise2** - директория с тестами для задания Hw7.Exercise2; все тесты запрещены к редактированию;
    - **Exercise3** - директория с тестами для задания Hw7.Exercise2;
        - **CurrencyServiceTests.cs** - тесты сервиса Hw7.Exercise3.CurrencyService, все тест-кейсы которого запрещены к редактированию, кроме приватных методов : GetStorageMock, GetStorageMockWithException, GetNotificationsMock.


## Задание 1. Библиотека "Threads"

Класс `Threads` создан для помощи программисту в работе с потоками.

Класс содержит два метода :
- метод `StartAll` - запускает потоки для каждого аргумента из списка аргументов;
- метод `WaitAll` - который ожидает завершения коллекции потоков.

**Требования к методам класса Threads :**
- метод `Threads.StartAll(ParameterizedThreadStart entryPoint, IEnumerable<object> args)` :
    - **создает, запускает и возвращает** n-потоков для каждого из n-аргументов args;
    - точкой входа для каждого потока явдяется `entryPoint`;
    - перечесление `args` может содержать `null`;
    - бросает исключение `ArgumentNullException`, если один из параметров (`entryPoint` или `args`) не содержит значения (равен `null`);
- метод `Threads.WaitAll(IEnumerable<Thread> threads)` :
    - блокирует вызывающий поток, до тех пор, пока все потоки `threads` не закончат свое выполнение;
    - бросает исключение `ArgumentNullException`, если параметр `threads` не содержит значения (равен `null`).

**Требования к тестовой нагрузке `PrimesLoad` (`Hw7.Tests.Exercise1`)**
- создает вычислительную нагрузку во время поиска простых чисел;
- содержит **ПОТОКОБЕЗПОСНЫЙ** кеш простых чисел;
- добавляет каждое найденно (во время работы) простое число в кеш простых чисел (метод `AppendPrimesCache`);
- позволяет получить все содержимое кеша простых чисел на текущий момент (метод `GetPrimesCache`).

**Программисту требует реализовать методы :**
- класс `Threads` :
    - метод `StartAll`;
    - метод `WaitAll`;
- класс `PrimesLoad` (`Hw7.Tests.Exercise1`) :
    - метод `AppendPrimesCache`;
    - метод `GetPrimesCache`.

## Задание 2. Библиотека "RecurrentJob"

Класс `RecurrentJob` создан для выполнения некоторой работы заданное количество раз, через фиксированный интервал времени.

Например 10 раз, через 1 секунду выводить на консоль текущее время.

**Требования к классу `RecurrentJob` :**
- "под капотом" использует **один из таймеров** : 
    - `System.Threading.Timer` (предпочтительный вариант);
    - `System.Timers.Timer`;
    - `System.Threading.PeriodicTimer`;
- имеет только приватный (`private`) конструктор;
- создается только через статический метод `RecurrentJob.Run(TimeSpan dueTime, TimeSpan interval, int times, Action<int, object?> job, object? context)`
    - который возвращает новосозаднный объект `RecurrentJob`;
    - который принимает :
        - `dueTime` - задержка перед первым вызовом `job`;
        - `interval` - задержка между остальныйми вызовами `job`;
        - `times` - количество вызовов `job`;
        - `job` - ссылка на метод обратного вызова, который собственно и представляет полезную работу;
        - `context` - произвольный контекст, который должен быть передан в job;
    - который генерирует исключение `ArgumentOutOfRangeException`, если один из аргументов `dueTime`, `interval` или `times` содержат отрицательное значения;
    - который генерирует исключение  `ArgumentNullException`, если `job` не содержит значения (равен `null`);
- содержит флаг `IsRunning`, который сигнализирует, что работа все еще выполняется;
- реализует интерфейс IDisposable;
    - метод Dispose останавливает внутренние таймеры, что предупреждает последующие вызовы `job` и устанавливает флаг `IsRunning` в `false`;
- после выполнения работы заданное количество раз `times`, внутренний таймер должен быть остановлен, а флаг `IsRunning` должен равнятся `false` (фактически это равносильно вызову метода `Dispose`)

**Программисту требуется реализовать :**
- Класс `RecurrentJob`
    - приватный конструктор `RecurrentJob`;
    - метод `Run`;
    - метод `Dispose`.

**Сценарий использования RecurrentJob :**
- программист, через метод `RecurrentJob.Run` создает работу, которая будет выполнятся `times` раз, с задержкой `dueTime` перед первым вызовом и задержкой `interval` между последующими вызовами `job`;
- программист может задать произвольный контекст `context`, который будет каждый раз передаваться в `job`;
- так же в `job` будет передаваться и счетчик вызовов `job` (остчет с нуля, т.е. первый вызов имеет номер `0`);
- когда работа выполнена заданное количество раз, ожидается поведение, равносильное вызову методу `Dispose`
- если программист желает остановить `RecurrentJob`, до того как завершиться робота, то он может візвать `Dispose` самостоятельно.

## Задание 3. Сервис "CurrencyService" (и создание "моков")

В данном задании, под "моком" понимается условная реализация некоторого интерфейса специальным инструментом NSubstitute.

Суть задания в том, что необходимо протестировать `Hw7.Exercise3.CurrencyService`, без реализации его зависимостей самостоятельно.

Для реализации зависимостей `CurrencyService`, в тестовом проекте `Hw7.Tests.Exercise3.CurrencyServiceTests`, необходимо использовать пакет **NSubstitute** (уже добавлен в тестовый проект).

`CurrencyService` - сервис, который позволяет работать с курсами валют : получать\задавать курсы валют, а также проводить обмен валют :
- получает зависимости через конструктор : 
    - интерфейс `ICurrencyStorage` - абстракция базы данных;
    - интерфейс `ICurrencyNotifications` - абстракция шины данных;
- реализует **важное** требование : в случае неудачного обновления курса валют, не публикует информацию об изменении курса в шину данных.

**Программисту требуется, с помощью `NSubstitute` реализовать следующие методы класса `CurrencyServiceTests` :**
- метод `GetStorageMock` - возвращает "мок" `ICurrencyStorage`, который настроен так, чтобы возвращать заданные курсы валют при обращении к методу `ICurrencyStorage.GetCurrencyRate`.
- метод `GetStorageMockWithException` - возвращает "мок" `ICurrencyStorage`, который настроен так, чтобы бросать исключение, при обращении к методу `ICurrencyStorage.UpsertCurrencyRate`.
- метод `GetNotificationsMock` - возвращает "мок" `ICurrencyNotifications`.

**Важно :** реализовывать `ICurrencyStorage`, `ICurrencyNotifications` самостоятельно (создавать классы, которые имплементируют указанные интерфейсы) - **ЗАПРЕЩЕНО**.

## Подсказки :
- Для ожидание завершения списка потоков, можно использовать метод `Thread.Join()` в цикле.
- Для реализации потокобезопасного кеша, можно воспользоваться одной из потокобезопасных коллекций или использовать блокировки; однако коллекция более предпочтительна.
- Чтобы остановить таймер - лучший вариант вызвать метод `Dispose`.
- Примеры создания "моков" NSubstitute доступны на сайте продукта https://nsubstitute.github.io/.
